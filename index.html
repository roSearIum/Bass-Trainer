<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bassist's Game</title>
  <style>
    body { font-family: Arial, sans-serif; text-align:center; margin-top:30px; }
    h1 { font-size: 42px; margin-bottom: 10px; }
    #note { font-size: 40px; margin:20px; }
    #result { font-size: 24px; margin:15px; }
    #score { font-size: 20px; margin:20px; }
    #timer { font-size: 18px; color: darkred; margin:10px; }
    button, select { padding:10px 20px; font-size:18px; margin: 5px; }
    .progress-container { width: 300px; height: 20px; background: #ddd; margin: 10px auto; border-radius: 10px; overflow: hidden; }
    .progress-bar { height: 100%; background: #e74c3c; width: 100%; transition: width 1s linear; }
  </style>
</head>
<body>
  <h1>Bassist's Game</h1>

  <div>
    Instrument:
    <select id="instrument">
      <option value="4">Bass 4 Strings (EADG)</option>
      <option value="5" selected>Bass 5 Strings (BEADG)</option>
    </select>
  </div>

  <div>
    Difficulty:
    <select id="difficulty">
      <option value="10000">Very Easy (10s)</option>
      <option value="6000">Easy (6s)</option>
      <option value="4000">Intermediate (4s)</option>
      <option value="3000" selected>Advanced (3s)</option>
      <option value="2000">Ass Kicker (2s)</option>
    </select>
  </div>

  <div id="note">Press Start</div>
  <div id="result"></div>
  <div id="timer"></div>
  <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
  <div id="score"></div>

  <button onclick="startGame()">Start Game</button>
  <button onclick="togglePause()">Pause / Resume</button>

  <!-- Pitchy (ESM) -->
  <script type="module">
    import { PitchDetector } from 'https://cdn.jsdelivr.net/npm/pitchy@4.0.1/dist/pitchy.esm.js';

    const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const TOL_CENTS = 35;         // ±35 cents tolerance
    const PREGAIN_DB = 2.0;       // προενίσχυση ανάλυσης (1.0=ουδέτερο, 2.0≈+6dB)
    const CLARITY_MIN = 0.6;      // ελάχιστο clarity για να θεωρηθεί έγκυρη μέτρηση
    const DETECTOR_SIZE = 2048;   // παράθυρο Pitchy (ταιριάζει με τα samples που ταΐζουμε)

    let fretboard = [];
    let audioCtx, analyser, dataArray, source, detector, preGain;
    let target = null, round = 0, score = 0;
    let paused = false, gameActive = false, timeoutHandle = null, timerInterval = null, pollHandle = null;
    let timeLeft = 0, totalTime = 0;

    function buildFretboard(type){
      const strings = (type==="5")
        ? [ {name:"B",freq:30.87}, {name:"E",freq:41.20}, {name:"A",freq:55.00}, {name:"D",freq:73.42}, {name:"G",freq:98.00} ]
        : [ {name:"E",freq:41.20}, {name:"A",freq:55.00}, {name:"D",freq:73.42}, {name:"G",freq:98.00} ];
      fretboard = [];
      for (let s of strings){
        for (let fret=0; fret<=12; fret++){
          const freq = s.freq * Math.pow(2, fret/12);
          const n = noteNames[Math.round(12 * Math.log2(freq/16.35)) % 12];
          fretboard.push({string:s.name, fret:fret, note:n, freq:freq});
        }
      }
    }

    async function initMic(){
      if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioCtx.createMediaStreamSource(stream);

        // Προενίσχυση πριν από τον analyser (ΔΕΝ συνδέεται στο destination -> δεν ακούγεται/δεν κάνει feedback)
        preGain = audioCtx.createGain();
        preGain.gain.value = PREGAIN_DB;

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 4096; // ↑ μεγαλύτερο FFT για χαμηλές συχνότητες
        const fftLen = analyser.fftSize;
        const tmpBuffer = new Float32Array(fftLen);
        dataArray = new Float32Array(DETECTOR_SIZE); // τροφοδοσία Pitchy

        source.connect(preGain);
        preGain.connect(analyser);

        detector = PitchDetector.forFloat32Array(DETECTOR_SIZE);

        // Αποθηκεύουμε βοηθητικά buffers στο αντικείμενο ώστε να τα ξαναχρησιμοποιούμε στη sampleAndJudge
        initMic._tmpBuffer = tmpBuffer;
      }
    }

    function midiFromFreq(f){ return 69 + 12 * Math.log2(f/440); }
    function freqFromMidi(m){ return 440 * Math.pow(2, (m-69)/12); }
    function noteIndexFromMidi(m){
      return ((Math.round(m) - 12) % 12 + 12) % 12; // 0=C ... 11=B
    }

    function startGame(){
      buildFretboard(document.getElementById("instrument").value);
      score = 0; round = 0; gameActive = true; paused = false;
      document.getElementById("score").innerText = `Score: 0 / 0`;
      initMic().then(nextRound);
    }

    function nextRound(){
      if (!gameActive || paused) return;
      if (round >= 35){
        document.getElementById("note").innerText="Game Over!";
        document.getElementById("result").innerText=`Final Score: ${score} / ${round}`;
        document.getElementById("timer").innerText="";
        document.getElementById("progressBar").style.width="0%";
        stopPolling();
        gameActive = false;
        return;
      }
      target = fretboard[Math.floor(Math.random()*fretboard.length)];
      round++;
      document.getElementById("note").innerText = `${target.note} on ${target.string} string`;
      document.getElementById("result").innerText = "Play now!";

      totalTime = parseInt(document.getElementById("difficulty").value);
      timeLeft = totalTime/1000;
      document.getElementById("timer").innerText = `Time left: ${timeLeft}s`;
      document.getElementById("progressBar").style.width="100%";

      clearInterval(timerInterval);
      timerInterval = setInterval(()=>{
        timeLeft -= 1;
        if (timeLeft>=0){
          document.getElementById("timer").innerText = `Time left: ${timeLeft}s`;
          document.getElementById("progressBar").style.width = (timeLeft*1000/totalTime*100) + "%";
        }
      },1000);

      clearTimeout(timeoutHandle);
      timeoutHandle = setTimeout(()=>{
        document.getElementById("result").innerText="⏰ Timeout / No sound";
        playBeep("wrong");
        stopPolling();
        setTimeout(nextRound,1000);
      }, totalTime);

      startPolling();
    }

    function startPolling(){
      stopPolling();
      pollHandle = setInterval(sampleAndJudge, 120); // ~8x/sec
    }
    function stopPolling(){
      if (pollHandle){ clearInterval(pollHandle); pollHandle=null; }
    }

    function sampleAndJudge(){
      if (!gameActive || paused) return;

      // Πάρε fftSize δείγματα από τον analyser και κόψε κεντρικά DETECTOR_SIZE για το Pitchy
      const tmp = initMic._tmpBuffer;
      analyser.getFloatTimeDomainData(tmp);
      const start = Math.floor((tmp.length - DETECTOR_SIZE)/2);
      for (let i=0;i<DETECTOR_SIZE;i++) dataArray[i] = tmp[start + i];

      const [pitch, clarity] = detector.findPitch(dataArray, audioCtx.sampleRate);
      if (!pitch || !isFinite(pitch) || clarity < CLARITY_MIN) return; // αγνόησε θορυβώδεις μετρήσεις

      const playedMidi = Math.round(midiFromFreq(pitch));
      const playedFreqNearest = freqFromMidi(playedMidi);
      const playedIndex = noteIndexFromMidi(playedMidi);
      const targetIndex = noteNames.indexOf(target.note);
      const centsErr = 1200 * Math.log2(pitch / playedFreqNearest);

      if (playedIndex === targetIndex && Math.abs(centsErr) <= TOL_CENTS){
        // CORRECT
        score++;
        document.getElementById("result").innerText = `✅ Correct! ${target.note} (~${pitch.toFixed(1)} Hz)`;
        document.getElementById("score").innerText = `Score: ${score} / ${round}`;
        playBeep("correct");
        clearTimeout(timeoutHandle);
        clearInterval(timerInterval);
        stopPolling();
        setTimeout(nextRound, 400);
      } else {
        // WRONG feedback, μένει μέχρι timeout
        document.getElementById("result").innerText = `❌ Wrong (~${noteNames[playedIndex]} • ${pitch.toFixed(1)} Hz). Target: ${target.note}`;
        if (!sampleAndJudge._lastWrong || performance.now() - sampleAndJudge._lastWrong > 900) {
          playBeep("wrong");
          sampleAndJudge._lastWrong = performance.now();
        }
      }
    }

    function togglePause(){
      paused = !paused;
      if (paused){
        clearTimeout(timeoutHandle);
        clearInterval(timerInterval);
        stopPolling();
        document.getElementById("result").innerText="⏸ Paused";
      } else {
        document.getElementById("result").innerText="▶ Resumed";
        setTimeout(nextRound,500);
      }
    }

    function playBeep(type="correct"){
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.type = "sine";
      if (type==="correct"){ osc.frequency.value = 880; gain.gain.value = 0.1; }
      else { osc.frequency.value = 220; gain.gain.value = 0.12; }
      osc.start();
      osc.stop(ctx.currentTime + 0.15);
    }
  </script>
</body>
</html>
