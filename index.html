<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bassist's Game</title>
  <style>
    body { font-family: Arial, sans-serif; text-align:center; margin:0; padding:30px 10px; background:#000; color:#fff; }
    h1 { font-size: 42px; margin: 0 0 10px; }
    #note { font-size: 72px; margin:20px 0; color: #e74c3c; font-weight: 800; letter-spacing: 1px; }
    #result { font-size: 28px; margin:10px 0 6px; min-height: 34px; }
    #score { font-size: 22px; margin:16px 0; }
    #timer { font-size: 20px; color: #ffcc00; margin:6px 0 8px; min-height: 24px; }
    .controls { margin: 8px 0 14px; display:flex; gap:8px; justify-content:center; flex-wrap: wrap; }
    select, button { padding:10px 16px; font-size:18px; border-radius:8px; border:1px solid #333; background:#111; color:#fff; cursor:pointer; }
    button:hover, select:hover { background:#151515; }
    .progress-container { width: 320px; height: 20px; background: #333; margin: 10px auto; border-radius: 10px; overflow: hidden; }
    .progress-bar { height: 100%; background: #e74c3c; width: 100%; transition: width 1s linear; }
    .status { font-size:14px; color:#aaa; margin-top:10px; min-height:18px; white-space:pre-line; }
    .error { color:#ff6b6b; }
    .ok    { color:#7fffd4; }
  </style>
</head>
<body>
  <h1>Bassist's Game</h1>

  <div class="controls">
    <label>
      Instrument:
      <select id="instrument">
        <option value="4">Bass 4 Strings (EADG)</option>
        <option value="5" selected>Bass 5 Strings (BEADG)</option>
      </select>
    </label>

    <label>
      Difficulty:
      <select id="difficulty">
        <option value="10000">Very Easy (10s)</option>
        <option value="6000">Easy (6s)</option>
        <option value="4000">Intermediate (4s)</option>
        <option value="3000" selected>Advanced (3s)</option>
        <option value="2000">Ass Kicker (2s)</option>
      </select>
    </label>

    <button id="startBtn">Start Game</button>
    <button id="pauseBtn">Pause / Resume</button>
  </div>

  <div id="note">Press Start</div>
  <div id="result"></div>
  <div id="timer"></div>
  <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
  <div id="score"></div>
  <div id="status" class="status"></div>

  <script>
    // ======= Constants & Utils =======
    const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const TOL_BASE_CENTS = 35;   // βάση ανοχής
    const TOL_LOW_BONUS  = 10;   // +cents για στόχους σε B/E
    const PREGAIN   = 3.0;       // ×3 προενίσχυση ανάλυσης
    const CLARITY_MIN = 0.6;

    function midiFromFreq(f){ return 69 + 12 * Math.log2(f/440); }
    function freqFromMidi(m){ return 440 * Math.pow(2, (m-69)/12); }
    function noteIndexFromMidi(m){ return ((Math.round(m) - 12) % 12 + 12) % 12; }

    // ======= Lightweight YIN (τοπικό, χωρίς CDN) =======
    function yinPitch(buffer, sampleRate){
      const n = buffer.length;
      const tauMax = Math.floor(n/2);
      const yin = new Float32Array(tauMax);
      let runningSum = 0;

      for (let tau=1; tau<tauMax; tau++){
        let sum = 0;
        for (let i=0; i<tauMax; i++){
          const d = buffer[i] - buffer[i+tau];
          sum += d*d;
        }
        yin[tau] = sum;
      }
      yin[0] = 1;
      for (let tau=1; tau<tauMax; tau++){
        runningSum += yin[tau];
        yin[tau] = runningSum ? (yin[tau] * tau / runningSum) : 1;
      }

      let tau = 2;
      const thresh = (1 - CLARITY_MIN);
      for (; tau<tauMax; tau++){
        if (yin[tau] < thresh) break;
      }
      if (tau === tauMax) return [null, 0];

      let x0 = (tau < 1) ? tau : tau-1;
      let x2 = (tau+1 < tauMax) ? tau+1 : tau;
      const s0 = yin[x0], s1 = yin[tau], s2 = yin[x2];
      const betterTau = (x0===tau || x2===tau) ? tau : tau + (s2 - s0) / (2*(2*s1 - s2 - s0));

      const pitch = sampleRate / betterTau;
      const probability = 1 - s1;
      return [pitch, probability];
    }

    // ======= App State =======
    const instrumentSel= document.getElementById('instrument');
    const difficultySel= document.getElementById('difficulty');
    const startBtn     = document.getElementById('startBtn');
    const pauseBtn     = document.getElementById('pauseBtn');
    const noteEl       = document.getElementById('note');
    const resultEl     = document.getElementById('result');
    const scoreEl      = document.getElementById('score');
    const timerEl      = document.getElementById('timer');
    const barEl        = document.getElementById('progressBar');
    const statusEl     = document.getElementById('status');

    let fretboard=[], audioCtx, analyser, dataBuf, source, preGainNode, hp, lp;
    let target=null, round=0, score=0;
    let paused=false, gameActive=false, timeoutHandle=null, timerInterval=null, pollHandle=null;
    let timeLeft=0, totalTime=0, tmpBuffer;

    // σταθερότητα: χρειάζονται 3 συνεχόμενες συμφωνίες
    const agreeBuffer = [];
    const AGREE_NEED  = 3;

    function setStatus(msg, cls){
      statusEl.className = 'status' + (cls ? ' ' + cls : '');
      statusEl.textContent = msg;
    }

    function buildFretboard(type){
      const strings = (type==="5")
        ? [ {name:"B",freq:30.87}, {name:"E",freq:41.20}, {name:"A",freq:55.00}, {name:"D",freq:73.42}, {name:"G",freq:98.00} ]
        : [ {name:"E",freq:41.20}, {name:"A",freq:55.00}, {name:"D",freq:73.42}, {name:"G",freq:98.00} ];
      fretboard = [];
      for (let s of strings){
        for (let fret=0; fret<=12; fret++){
          const f = s.freq * Math.pow(2, fret/12);
          const n = noteNames[Math.round(12 * Math.log2(f/16.35)) % 12];
          fretboard.push({string:s.name, fret:fret, note:n, freq:f});
        }
      }
    }

    async function initMic(){
      if (audioCtx) return;
      try{
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state !== 'running') await audioCtx.resume();

        setStatus('Requesting mic…');
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        source = audioCtx.createMediaStreamSource(stream);

        // Gain -> HighPass -> LowPass -> Analyser
        preGainNode = audioCtx.createGain();
        preGainNode.gain.value = PREGAIN;

        hp = audioCtx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = 35;  // κόψε DC/rumble

        lp = audioCtx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.value = 1200; // κόψε άχρηστα πολύ υψηλά

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 8192;             // πιο σταθερό στα χαμηλά
        tmpBuffer = new Float32Array(analyser.fftSize);
        dataBuf   = new Float32Array(4096);  // παράθυρο προς YIN

        // chain
        source.connect(preGainNode);
        preGainNode.connect(hp);
        hp.connect(lp);
        lp.connect(analyser);

        setStatus('Mic ready. Listening…', 'ok');
      }catch(e){
        console.error(e);
        setStatus('Mic access denied/failed. Check site permissions (lock icon) → Microphone: Allow.', 'error');
        throw e;
      }
    }

    function startGame(){
      buildFretboard(instrumentSel.value);
      score = 0; round = 0; gameActive = true; paused = false;
      agreeBuffer.length = 0;
      scoreEl.innerText = `Score: 0 / 0`;
      initMic().then(nextRound);
    }

    function nextRound(){
      if (!gameActive || paused) return;
      if (round >= 35){
        noteEl.innerText   = "Game Over!";
        resultEl.innerText = `Final Score: ${score} / ${round}`;
        timerEl.innerText  = "";
        barEl.style.width  = "0%";
        stopPolling();
        gameActive = false;
        return;
      }
      target = fretboard[Math.floor(Math.random()*fretboard.length)];
      round++;
      agreeBuffer.length = 0; // reset σταθερότητας
      noteEl.innerText   = `${target.note} on ${target.string}`;
      resultEl.innerText = "Play now!";

      totalTime = parseInt(difficultySel.value, 10);
      timeLeft = totalTime/1000;
      timerEl.innerText = `Time left: ${timeLeft}s`;
      barEl.style.width = "100%";

      clearInterval(timerInterval);
      timerInterval = setInterval(()=>{
        timeLeft -= 1;
        if (timeLeft>=0){
          timerEl.innerText = `Time left: ${timeLeft}s`;
          barEl.style.width = (timeLeft*1000/totalTime*100) + "%";
        }
      },1000);

      clearTimeout(timeoutHandle);
      timeoutHandle = setTimeout(()=>{
        resultEl.innerText = "⏰ Timeout / No sound";
        playBeep("wrong");
        stopPolling();
        setTimeout(nextRound,1000);
      }, totalTime);

      startPolling();
    }

    function startPolling(){ stopPolling(); pollHandle = setInterval(sampleAndJudge, 120); }
    function stopPolling(){ if (pollHandle){ clearInterval(pollHandle); pollHandle=null; } }

    function bestOctaveFit(pitchHz){
      // Δοκίμασε pitch και 2×pitch (για να «σώσεις» χαμηλές που διαβάζονται σε ανώτερη οκτάβα)
      const candidates = [pitchHz, pitchHz*2];
      let best = null;
      for (const p of candidates){
        const playedMidi = Math.round(midiFromFreq(p));
        const playedFreqNearest = freqFromMidi(playedMidi);
        const centsErr = 1200 * Math.log2(p / playedFreqNearest);
        const idx = noteIndexFromMidi(playedMidi);
        const absErr = Math.abs(centsErr);
        if (!best || absErr < best.absErr){
          best = { idx, centsErr, absErr, pitch: p };
        }
      }
      return best; // {idx, centsErr, absErr, pitch}
    }

    function sampleAndJudge(){
      if (!gameActive || paused) return;

      analyser.getFloatTimeDomainData(tmpBuffer);
      // πάρε κεντρικό παράθυρο προς YIN
      const start = Math.floor((tmpBuffer.length - dataBuf.length)/2);
      for (let i=0;i<dataBuf.length;i++) dataBuf[i] = tmpBuffer[start + i];

      // απλό high-pass σε δείγματα (πέρα από το biquad) για ασφάλεια
      let prev = dataBuf[0];
      for (let i=1;i<dataBuf.length;i++){
        const cur = dataBuf[i];
        dataBuf[i] = cur - 0.995*prev;
        prev = cur;
      }

      const [rawPitch, prob] = yinPitch(dataBuf, audioCtx.sampleRate);
      if (!rawPitch || !isFinite(rawPitch) || prob < CLARITY_MIN) return;

      const fit = bestOctaveFit(rawPitch);
      const targetIndex = noteNames.indexOf(target.note);

      // δυναμική ανοχή: extra για B/E στόχους
      const tol = TOL_BASE_CENTS + ( (target.string === 'B' || target.string === 'E') ? TOL_LOW_BONUS : 0 );

      const ok = (fit.idx === targetIndex) && (Math.abs(fit.centsErr) <= tol);

      // Σταθερότητα: χρειάζομαι 3 διαδοχικές συμφωνίες
      agreeBuffer.push(ok);
      if (agreeBuffer.length > AGREE_NEED) agreeBuffer.shift();

      if (ok && agreeBuffer.length === AGREE_NEED && agreeBuffer.every(Boolean)){
        score++;
        resultEl.innerText = `✅ Correct! ${target.note} (~${fit.pitch.toFixed(1)} Hz)`;
        scoreEl.innerText  = `Score: ${score} / ${round}`;
        playBeep("correct");
        clearTimeout(timeoutHandle);
        clearInterval(timerInterval);
        stopPolling();
        setTimeout(nextRound, 400);
      } else if (!ok) {
        const name = noteNames[fit.idx];
        resultEl.innerText = `❌ Wrong (~${name} • ${fit.pitch.toFixed(1)} Hz). Target: ${target.note}`;
        if (!sampleAndJudge._lastWrong || performance.now() - sampleAndJudge._lastWrong > 900) {
          playBeep("wrong");
          sampleAndJudge._lastWrong = performance.now();
        }
      }
    }

    function togglePause(){
      paused = !paused;
      if (paused){
        clearTimeout(timeoutHandle);
        clearInterval(timerInterval);
        stopPolling();
        resultEl.innerText = "⏸ Paused";
      } else {
        resultEl.innerText = "▶ Resumed";
        setTimeout(nextRound,500);
      }
    }

    function playBeep(type="correct"){
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        ctx.resume && ctx.resume();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        osc.type = "sine";
        if (type==="correct"){ osc.frequency.value = 880; gain.gain.value = 0.1; }
        else { osc.frequency.value = 220; gain.gain.value = 0.12; }
        osc.start(); osc.stop(ctx.currentTime + 0.15);
      }catch(_){}
    }

    // Bind buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);

    setStatus('Ready. Click Start Game and allow the mic.', 'ok');
  </script>
</body>
</html>
